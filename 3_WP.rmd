---
title: "WP_3"
author: "R.Spielhofer"
date: "31/08/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(raster)
require(rgdal)
require(snow)
require(mapview)
require(dplyr)
require(ggplot2)
require(sf)
require(sp)
require(ecr)
require(Hmisc)
require(tmap)
require(tmaptools)
require(DBI)
require(RPostgres)
require(rpostgis)
require(mapview)
require(maptools)
require(reticulate)
require(spatstat)
require(RPostgreSQL)

con<- dbConnect(Postgres(), dbname = "publication_3_fin", host = "localhost", user = "postgres", password
                        = "reto89LLSIMI")
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
#import all  points from WP2
```{r cars}

#cen<-st_read("D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/intermediate_steps/2_wp/WP_2_fin_200831.shp")

cen<-st_read(dsn = con, Id(schema="WT_PU_HEX", table = "CEN_FIN_200922"))


```

#Objective functions
This section defines the objectives as a function of x. While x is a binary vector [0,1] with the length specified in the optimization part. 
```{r helper functions}

ener_dens<-function(x){
    ener<-sum(x*cen$ENER_DENS)/sum(x)
    return(ener)
     }  


#counts the amount of WT in a model run
amount_WT<-function(x){
  am_WT<-sum(x)
return(am_WT)}


  
# thats the clark evens index (the smaller the value below 0 the more clustered the data is)
cluster_fun<-function(x){
  cen$X<-x
  tmp<-subset(cen,X==1)
  tmp.ppp<-as.ppp.SpatialPoints(tmp)
  ce<-clarkevans(tmp.ppp)
  return(ce[3])
}

```

# choosing the scenario
In order to automate the optimization of many scenario we need to define the points the NSGA2 considers in each sceanario. We store the respective point data in the postgres SQL DB in the "scenario" schema. 
```{r}

#if necessary, subset the data for testing
#cen<-cen[2400:2600,]
cur_dat<-Sys.Date()
#NO_CONSTR
scen_name<-paste("B1",cur_dat,sep = "_")
st_write(obj = cen, dsn = con, Id(schema="scenario", table = scen_name))

#No exclusion areas
tmp<-subset(cen,cen$IN_EXCL==0)
scen_name<-paste("B2",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

#OTHER
tmp<-subset(cen,cen$IN_OTHER==1)
scen_name<-paste("B3",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

##### FOREST ####################
#not in forest
tmp<-subset(cen,cen$DIST_FOR>1)
scen_name<-paste("B1_NOT_IN_FOR",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

#plus_Forest
tmp<-subset(cen,cen$DIST_FOR>300)
scen_name<-paste("B1_FOR+",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

#plus_plus_Forest
tmp<-subset(cen,cen$DIST_FOR>600)
scen_name<-paste("B1_FOR++",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

##not in exclusion B2

#not in forest
tmp<-subset(cen,cen$DIST_FOR>1 & cen$IN_EXCL==0)
scen_name<-paste("B2_NOT_IN_FOR",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

#plus_Forest
tmp<-subset(cen,cen$DIST_FOR>300 & cen$IN_EXCL==0)
scen_name<-paste("B2_FOR+",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

#plus_plus_Forest
tmp<-subset(cen,cen$DIST_FOR>600 & cen$IN_EXCL==0)
scen_name<-paste("B2_FOR++",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

##only other areas B3


#plus_Forest
tmp<-subset(cen,cen$DIST_FOR>300 & cen$IN_OTHER==1)
scen_name<-paste("B3_FOR+",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

#plus_plus_Forest
tmp<-subset(cen,cen$DIST_FOR>600 & cen$IN_OTHER==1)
scen_name<-paste("B3_FOR++",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

##### Housing zones ####################
tmp<-subset(cen,cen$DIST_HZ>300)
scen_name<-paste("B1_HZ+",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

tmp<-subset(cen,cen$DIST_HZ>1200)
scen_name<-paste("B1_HZ++",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

tmp<-subset(cen,cen$DIST_HZ>300 & cen$IN_EXCL==0)
scen_name<-paste("B2_HZ+",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

tmp<-subset(cen,cen$DIST_HZ>1200 & cen$IN_EXCL==0)
scen_name<-paste("B2_HZ++",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

tmp<-subset(cen,cen$DIST_HZ>300 & cen$IN_OTHER==1)
scen_name<-paste("B3_HZ+",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

tmp<-subset(cen,cen$DIST_HZ>1200 & cen$IN_OTHER==1)
scen_name<-paste("B3_HZ++",cur_dat,sep = "_")
st_write(obj = tmp, dsn = con, Id(schema="scenario", table = scen_name))

```

# The NSGA2 optimization
```{r}
#define some empty lists which store the results for each scenario
fitness_list<-list()
ScenName_list<-list()
scen_vec<-vector()

path_fitness<-"D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/intermediate_steps/3_wp/OPTIM_RES/fitness"
path_population<-"D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/intermediate_steps/3_wp/OPTIM_RES/population"

#these are the boundaries for the wind energy target of Switzerland
low_targ<-4299000
up_targ<-4400000

#checking the files in the DB (scenario schema) which have been stored during the previous section
scen_names<-dbGetQuery(con,"SELECT table_name FROM information_schema.tables WHERE table_schema='scenario'AND table_name like '%FOR%'")


#the fitness function calls the three optimization functions. If the energy target is not reached from the individual WT configuration, very high (low) values will be returned
 fitness.fun = function(x){
  if((sum(x*cen$prod_MW)>low_targ)& (sum(x*cen$prod_MW)<up_targ)){
    res<-c(ener_dens(x),amount_WT(x),cluster_fun(x))
  }
  else{res<-c(-10^20,10^20,10^20)}
    return(res)
  }

#global NSGA2 settings
MU = 80; LAMBDA = MU-5;  MAX.ITER =200
 
# Here we loop through all scenario files from the DB and calculate the optimization
for(a in 1:nrow(scen_names)){
  ScenName_list[a]<-as.character(scen_names[a,])

  #read out the points with the name of the name list at position a
  cen<-st_read(dsn = con, Id(schema="scenario", table = as.character(scen_names[a,])))
  cen<-as_Spatial(cen)
  
  #the bounds are calculated to establish an initial population which can reach the energy target (we add +- 10% to    the boundaries)
  bound_up<-up_targ/sum(cen$prod_MW)+0.1*up_targ/sum(cen$prod_MW)
  bound_low<-low_targ/sum(cen$prod_MW)-0.1*low_targ/sum(cen$prod_MW)
  
  
  #we check if there are enough points to reach the energy target of 4.3TWh/y
  if(sum(cen$prod_MW)<low_targ | bound_up>1){
    print(" is not possible to optimize")
    next
    #otherwise proceed with the optimization
  } 
  else{
    print(" will be optimized!!")
    #cen specific NSGA2 settings
    N.BITS = nrow(cen)
    #control settings
    ctrl<-initECRControl(fitness.fun, n.objectives = 3L, minimize = c(FALSE,TRUE,TRUE))
    ctrl<-registerECROperator(ctrl, "mutate", mutBitflip, p=1/N.BITS)
    ctrl<-registerECROperator(ctrl, "recombine", recCrossover)
    ctrl<-registerECROperator(ctrl, "selectForMating", selSimple)
    ctrl<-registerECROperator(ctrl, "selectForSurvival",  selNondom)
  
    #WE NEED TO DEFINE A VECTOR WITH the lower and the upper bounds of ONES and ZEROS in order to reach the target       specified in the goals
    population<-list()
    for(i in 1:MU){
      x3 <- sample(round(100*bound_low):round(100*bound_up), 1)
      pop_vec<-(sample(1:0, size=nrow(cen), prob=c(x3,100-x3), replace=TRUE))
      population[[i]]<-pop_vec
    }
    #The initial population and it's fitness
    fitness = evaluateFitness(ctrl , population)
  
    #since the compute HV only works for minimized goals, we need to transform the only maximized goal
    fitness2<-fitness
    fitness2[1,]<-fitness2[1,]*-1
   
    ##Setting up the statistics HV   
    ref.point<-c(8,1000,1)
  
    logger<-initLogger(ctrl,log.stats = list(fitness = list("HV"=list(fun=computeHV, pars = list(ref.point=ref.point)))),init.size = MAX.ITER+1L)
    updateLogger(logger,population=population, fitness = fitness2, n.evals=MU)
  
    ##And here we iterate MAX.iter times through and recombine the individuals to establish optimal solutions for each scenario.
                                             
    start<-Sys.time()
    for(i in seq_len(MAX.ITER)){
      #offspring<-mutate(ctrl, population, p.mut = 0.9)
      offspring<-generateOffspring(ctrl, population, fitness, LAMBDA, p.recomb = 0.8, p.mut = 0.2)
      fitness.o<-evaluateFitness(ctrl,offspring)
      #new selection
      sel<-replaceMuPlusLambda(ctrl, population, offspring, fitness, fitness.o)
      #selected population
      population<-sel$population
      fitness<-sel$fitness
      fitness2<-fitness
      fitness2[1,]<-fitness2[1,]*-1
  
      updateLogger(logger, population, fitness = fitness2,n.evals = LAMBDA)
      #autoplot(getStatistics(logger))
      #pareto_arch<-updateParetoArchive(pareto_arch,population,fitness = fitness)
    }
    end<-Sys.time()
    print(end-start)
  
    stats<-getStatistics(logger)
    #save HV curve
    jpeg(file=paste("D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/intermediate_steps/3_wp/OPTIM_RES/HV_curves/",paste(scen_names[a,],"_HV.jpg",sep=""),sep=""),width = 500, height = 300)
    plot(stats)
    dev.off()
  
    dom_fitness<-which(dominated(fitness)==T)
    dom_fitness<-fitness[1:3, dom_fitness]
  
    # as soon as the optimization is finished, the extreme populations are extracted (max enerdens, min evens and minimal amount of WT) in order to map these extreme individuals spatially for each scenario  
    enerdens_max<-which.max(fitness[1,])
    enerdens_max<-unlist(population[enerdens_max])

    amount_min<-which.min(fitness[2,])
    amount_min<-unlist(population[amount_min])

    #the minimal value of clark even index represents the maximal clustering
    clus_max<-which.min(fitness[3,])
    clus_max<-unlist(population[clus_max])

    #the extreme individuals are attached to the point layers
    cen$enerdens_max<-enerdens_max
    cen$amount_min<-amount_min
    cen$clus_max<-clus_max

    #calculate how often each site is in the pareto optimal in order to get a feeling about the confidence of the optimal sites
    b<-Reduce(`+`, population)
    #attach to cen
    cen$sum_pop_pareto<-b
  
    #store cen in the DB with the scenario NAME
    cen<-as.data.frame(cen)
    st_write(obj = cen, dsn = con, Id(schema="optim_res", table = as.character(paste(scen_names[a,],"_res",sep=""))))
 
    #and write the population and fitness into csv

    write.csv(fitness,paste(path_fitness,paste(scen_names[a,],"csv",sep="."), sep = "/"))
    write.csv(population,paste(path_population,paste(scen_names[a,],"csv",sep="."), sep = "/"))
  
    #store the fitness values of each scenario in the fitness list
    fitness_list[[paste0(scen_names[a,], a)]]<-fitness
    #and 
    scen_vec[a]<-scen_names[a,]  
  
    print(paste(paste(paste(a, " of total ",sep = ""), nrow(scen_names), sep=""), " scenarios are computed", sep = ""))
  } 
}

```