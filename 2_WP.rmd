---
title: "2_WP"
author: "R.Spielhofer"
date: "21 August 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(raster)
require(rgdal)
require(snow)
require(mapview)
require(dplyr)
require(ggplot2)
require(sf)
require(sp)
require(spatialEco)
require(Hmisc)
require(tmap)
require(tmaptools)
require(DBI)
require(RPostgreSQL)
require(rpostgis)
require(mapview)
require(reticulate)

con<- dbConnect("PostgreSQL", dbname = "publication_3_fin", host = "localhost", user = "postgres", password
                        = "reto89LLSIMI")

```

## Description of WP 2

This workpackages describes the exclusion of sites for wind energy production. Firstly, we exclude sites which are technically not feasible to develop. Secondly, we consider only sites which are outside "hard" restricted areas.  

# Slope
We assign the slope to the all the centroids and remove the points which have a slope <11.4 degrees = 20%. 

```{r cars}
dem_200<-raster("input_data/200_DEM.tif")
dem_200<-projectRaster(dem_200, crs="+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=600000 +y_0=200000 +ellps=bessel +towgs84=674.4,15.1,405.3,0,0,0,0 +units=m +no_defs")

slope<-terrain(dem_200, opt="slope", unit="degrees", neighbors=8)
#mapview(slope)

#import all centroids from WP1
cen_all<-pgGetGeom(conn = con,name = c("WT_PU_HEX","cen_all_2020-08-25"))
cen_all<-spTransform(cen_all,crs(dem_200))
pgInsert(con,c("WT_PU_HEX","cen_all_LV03"),cen_all)
test<-pgGetGeom(con,c("WT_PU_HEX","WT_PTS_LV03_200827"))

#assign slope and remove the sites with too steep slopes
cen_all$slope<-extract(slope,cen_all)
cen_all<-subset(cen_all,slope<11.4)
```

#Landcover

Secondly we remove all the points located within technically unfeasible zones (glaciers, lakes, swamps, rivers and rock fields) We therefore transform the TLM into a binary raster (0=all areas, 1=not feasible ares) 

```{r pressure, echo=FALSE}
rest_area = st_read(dsn="D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/input_data/CH_geom/TLM_BB.shp", query = "SELECT * FROM \"TLM_BB\" WHERE OBJEKTART = 10 OR 
                                                              OBJEKTART = 11 OR
                                                              OBJEKTART = 9 OR
                                                              OBJEKTART = 7 OR
                                                              OBJEKTART = 1")

rest_area<-as(st_zm(rest_area),"Spatial")
#create a raster after transforming into the new CRS
rest_area<-spTransform(rest_area,crs(cen_all))
rest_area<-st_as_sf(rest_area)

cen_all<-st_as_sf(cen_all)

cen_all = st_join(cen_all, rest_area["OBJEKTART"], left=T)
#and just keep the points which are not (na) in a specific area
cen_all<-filter(cen_all,is.na(cen_all$OBJEKTART))
cen_all<-as(cen_all,"Spatial")
mapview(cen_all)
pgInsert(con,c("WT_PU_HEX","cen_all_LC"),cen_all)

cen<-pgGetGeom(con,c("WT_PU_HEX","cen_all_LC"))
cen<-st_as_sf(cen)
st_write(cen,"D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/intermediate_steps", "cen_lc",driver = "ESRI shapefile")

tmp_pts = st_read(dsn="D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/intermediate_steps/tmp_re18.shp")
tmp_pts<-tmp_pts[ -23] 
names(tmp_pts)[23]<-"dist_WHZ"
st_write(tmp_pts,"D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/intermediate_steps", "tmp_re18",driver = "ESRI shapefile",overwrite=F)

```

#Further infrastructure

Additionally, we remove all the points which are within No building zones (+300m), airport zones (+4000m), streets (+50m) and  railway lines (+50m). 

```{r pressure, echo=FALSE}

#some statistics
install.packages("reshape2")
require(reshape2)
#wide to long for all distance measures
df_pts<-as.data.frame(tmp_pts)
melt.pts<-melt(df_pts[c(7:12,14:23)])

#histogram of all variables
ggplot(data = melt.pts, aes(x = value)) + 
geom_histogram() + 
facet_wrap(~variable, scales = "free")



tmp_pts<-subset(tmp_pts,dist_WHZ>300)
tmp_pts<-subset(tmp_pts,dist_air>4000)
tmp_pts<-subset(tmp_pts,dist_str>50)
tmp_pts<-subset(tmp_pts,dist_rail>50)

```


#Federal landscape and nature protection

Finally, points within Swiss Nationalparks and protected marshes will be also excluded. (dist_leag)

```{r pressure, echo=FALSE}
tmp_pts<-subset(tmp_pts,dist_LEAG>0)

#check where these points are and how much the WT might produce
pal<-mapviewPalette("mapviewSpectralColors")
mapview(tmp_pts, col.regions=pal(100), zcol=c("prod_MW")) 
```

# Further attributes
We attach meters above sea level (msl), the surrounding noise of the wt (noise) and the binary variable fff (1=in fff 0=not in fff) to all points.

```{r}
tmp_pts$msl<-extract(dem_200,tmp_pts)


noise<-raster("input_data/constr/StrassenLaerm_Tag.tif")
noise[is.na(noise[])] <- 0
tmp_pts$noise<-extract(noise,tmp_pts, buffer= 600, fun=mean)

##statistics about the street noise around the WT's
ggplot(data = tmp_pts, aes(x = noise)) + 
geom_histogram()

FFF<-raster("input_data/constr/FFF_proj.tif")
FFF[is.na(FFF[])] <- 0
tmp_pts$FFF<-extract(FFF,tmp_pts)
ggplot(data = tmp_pts, aes(x = FFF)) + 
geom_bar()

BEV<-raster("D:/04_PROJECTS/2001_WIND_OPTIM/in/BEVÃ–LKERUNG/bev_200.tif")
BEV[is.na(BEV[])] <- 0
crs(BEV)<-"+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs"


BEV<-projectRaster(BEV, dem_200)
crs(BEV)
writeRaster(BEV,"test/pop_dens_200.tif")

mapview(BEV)
#insert the 8800 pts into the database and store it as shp file
tmp_pts<-as(tmp_pts,"Spatial")
pgInsert(con,c("WT_PU_HEX","WT_pts_fin_200827"),tmp_pts)
st_write(tmp_pts,"D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/test", "all_pts",driver = "ESRI shapefile",overwrite=T)

#replace NA's with 0 to indicate that the 

```

## viewshed and further distance weighted attributes per WT
```{r}
#for the arcgis approach
library(reticulate)
Sys.setenv(RETICULATE_PYTHON = "C:/Python27/ArcGISx6410.7/python.exe")
use_python("C:/Python27/ArcGISx6410.7/python.exe",required = TRUE)
#Import arcpy
arcpy <- import("arcpy")

test1<-test[c(1:10),]
test1<-st_as_sf(test)
st_write(test1,"D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/viewshed_analysis", "view_inpoints",driver = "ESRI shapefile",overwrite=T)
```



Here we import all points convert these to a feature layer and calculate three values. Firstly with the arcpy function 3dviewshed, the viewshed for each single point is calculated with the parameters dependent of the WT model (radius and target height). We consider hub heights instead of total heights. This corrects slightly for the fact that the visibility is different depending on the angle the WT is observed. Secondly, we calculate a grid containing the inverse distances for all raster cells in the viewshed. Thirdly we calculate the visual impact as the mean of (viewshed * IDW) (far away visible pixels are less counted compared to closer pixels). Fourth, we multiply the IDW with the population density and calculate the mean. This results in a viewshed and distance weighted population density (high values indicate more people living close by the wind turbine) Finally, we do the same for the infrastructure (since combination of infrastructure is preferable, dense and close by infrastructure gets higher values where as less dense and more distant settings gets lower values).
```{python}
import arcpy
import os
import numpy as np
from arcpy import env
from arcpy.sa import IsNull

arcpy.CheckOutExtension("3D")
arcpy.CheckOutExtension("Spatial")

# Set overwrite option
arcpy.env.overwriteOutput = True

DEM = 'D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/viewshed_analysis/200_DEM.tif'

INFRA= 'D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/viewshed_analysis/INFRA_clip.tif'

POP_DENS= 'D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/viewshed_analysis/pop_dens_clip.tif'
COHER= 'D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/viewshed_analysis/COHER.tif'

arcpy.env.extent = POP_DENS

POP_DENS=arcpy.sa.Int(POP_DENS)
INFRA=arcpy.sa.Int(INFRA)

inpoints='D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/viewshed_analysis/inpoints.shp'



# ouput workspace and name for viewshed  
outputWS = 'D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/viewshed_analysis/out/view'  
prefixVS = 'Viewshed'  
arcpy.env.workspace = outputWS  
arcpy.env.overwriteOutput = True  



arcpy.MakeFeatureLayer_management(inpoints, 'pts_lyr')
#add three fields
arcpy.AddField_management ('pts_lyr', "VIS_AREA", "DOUBLE")
arcpy.AddField_management ('pts_lyr', "VIS_IMPACT", "DOUBLE")
arcpy.AddField_management ('pts_lyr', "VIS_INFRA", "DOUBLE")
arcpy.AddField_management ('pts_lyr', "VIS_POP", "DOUBLE")
arcpy.AddField_management ('pts_lyr', "COHER_AREA", "DOUBLE")

with arcpy.da.UpdateCursor('pts_lyr', ['PU_ID','LT','VIS_AREA','VIS_IMPACT','VIS_INFRA','VIS_POP','COHER_AREA']) as cursor:

   for row in cursor:
   
      fid = str(row[0])  ### Must be string
      lt = float(row[1])
  
      arcpy.SelectLayerByAttribute_management("pts_lyr", "NEW_SELECTION", '"PU_ID" = {}'.format(fid))
      

# define output name (of oid = 1, raster will be called Viewshed1  
      outVSname = outputWS + os.sep + prefixVS + str(fid)  
  
#set the parameters for the viewshed according to the WT_model according to P.Mattla 2020 and Wrozynski 2016


      if lt==1:
        #V150
        #print(fid," this is a V150 in landscape nr.",lt)
        obs_offset = 150
        outer_rad = 16000
           
      
      elif lt==2:
        print(fid, " this is an E82 in landscape nr." ,lt)
        obs_offset = 100
        outer_rad = 11000
            
      else:
        print(fid, " this is an E138 in landscape nr." ,lt)
        obs_offset = 125
        outer_rad = 14000
      
      outViewshed = arcpy.Viewshed2_3d(DEM, 'pts_lyr', outVSname,  surface_offset=1.5, observer_offset=obs_offset, outer_radius=outer_rad,  refractivity_coefficient=0.13)
      outViewshed = arcpy.sa.Int(outViewshed)
    
      # determine number of visible cells  
      myArray = arcpy.RasterToNumPyArray(outViewshed)  
      visPixels = myArray.sum()  
      #print(visPixels)
      del myArray
      
      #create the euclidean distance up to the outer radius with the same pixel size
      ECLE = arcpy.sa.EucDistance("pts_lyr", outer_rad, 200)
      #The IDW represents an approximation of the visual impact, since only visual pixel are counted and weighted less with increasing distance
      IDW = outViewshed * (1/ECLE)*outer_rad
      myArray3 = arcpy.RasterToNumPyArray(IDW) 
      myArray3[np.where(myArray3<0)]=0
      visIMPACT = myArray3.mean() 
      del myArray3

      outINFRA = IDW * INFRA
      myArray1 = arcpy.RasterToNumPyArray(outINFRA)  
      myArray1[np.where(myArray1 <0)]=0
      visINFRA = myArray1.mean() 
      #print(visINFRA)
      del myArray1
      
      outPOPdens = IDW * POP_DENS
      myArray2 = arcpy.RasterToNumPyArray(outPOPdens)  
      myArray2[np.where(myArray2 <0)]=0
      visPop = myArray2.mean() 
      del myArray2
      
      outCOHER=IDW * COHER
      myArray5 = arcpy.RasterToNumPyArray(outCOHER)  
      myArray5[np.where(myArray5 <0)]=0
      visCOHER = myArray5.mean() 
      
      del myArray5
      
      
        # update value in point featureclass
      
      row[2]=visPixels
      row[3]=visIMPACT
      row[5]=visPop
      row[4]=visINFRA
      row[6]=visCOHER
      cursor.updateRow(row)
      arcpy.SelectLayerByAttribute_management("pts_lyr", "CLEAR_SELECTION")
      #print(fid)
      
      #outINFRA.save(
      #"D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/test/out/infra/IDW_INFRA" +fid+".tif")
      #IDW.save("D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/test/out/idw/IDW" +fid+".tif")
      #outPOPdens.save(
      #"D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/test/out/pop_dens/IDW_POP" +fid+".tif")
     
arcpy.FeatureClassToShapefile_conversion('pts_lyr', "D:/04_PROJECTS/2001_WIND_OPTIM/WIND_OPTIM_git/viewshed_analysis/out")      
del row    
arcpy.CheckInExtension("3D")
arcpy.CheckInExtension("Spatial")
```



##Distance measures

In the next part we assign the distance in meters between the points which are technically possible (N=13'112) and the
*Forests (dist_for)
*Building zone (dist_BZ)
*Streets and Powerlines (Exploitation) (dist_street, dist_PL)
*BLN (dist_BLN)
*UNESCO (dist_UNESCO)
*ISOS (dist_ISOS)
*flood plains (dist_flood)
*DEER protection areas (dist_JB)
*Dry meadows (dist_MEAD)
*Bird protection areas (dist_bird)
*rivers (dist_riv)

```{r pressure, echo=FALSE}
plot(pressure)
```

# further spatial checks    
Finally we need to know for each point the Infrastructure density, the noise level and the landscape coherence